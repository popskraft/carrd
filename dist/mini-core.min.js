(function () {
'use strict';
const DEFAULTS = {
containerSelector: '.FAQContainer',
dividerSelector: 'hr.divider-component',
headerTags: ['H1', 'H2', 'H3'],
allowMultipleOpen: false,
defaultOpen: false  // Open first question by default
};
const externalOptions = (typeof window !== 'undefined' &&
window.CarrdPluginOptions &&
window.CarrdPluginOptions.faq) || {};
const CONFIG = { ...DEFAULTS, ...externalOptions };
const HEADER_TAGS = new Set(CONFIG.headerTags);
let answerIdCounter = 0;
const containers = document.querySelectorAll(CONFIG.containerSelector);
if (!containers.length) return;
const openAnswers = new Set();
const requestFrame = window.requestAnimationFrame || (cb => setTimeout(cb, 16));
let resizeHandle = null;
const scheduleOpenAnswerSync = () => {
if (resizeHandle !== null) return;
resizeHandle = requestFrame(() => {
openAnswers.forEach(answer => adjustHeight(answer));
resizeHandle = null;
});
};
const answerResizeObserver =
typeof ResizeObserver !== 'undefined'
? new ResizeObserver(entries => {
entries.forEach(entry => {
if (openAnswers.has(entry.target)) {
adjustHeight(entry.target);
}
});
})
: null;
let firstQuestion = true;
containers.forEach(container => {
const dividers = Array.from(container.querySelectorAll(CONFIG.dividerSelector)).filter(
divider => divider.closest(CONFIG.containerSelector) === container
);
if (!dividers.length) return;
dividers.forEach(startDivider => {
const endDivider = findNextDivider(startDivider);
const header = findHeaderBetween(startDivider, endDivider);
if (!header || header.dataset.faqBound === 'true') {
return;
}
const answerWrapper =
header.nextElementSibling && header.nextElementSibling.classList.contains('faq-answer')
? header.nextElementSibling
: wrapAnswerContent(header, endDivider);
if (!answerWrapper) {
return;
}
const shouldOpenByDefault = CONFIG.defaultOpen && firstQuestion;
prepareToggle(header, answerWrapper, shouldOpenByDefault);
firstQuestion = false;
});
});
window.addEventListener('resize', scheduleOpenAnswerSync);
window.addEventListener('orientationchange', scheduleOpenAnswerSync);
function findNextDivider(divider) {
let node = divider.nextElementSibling;
while (node) {
if (isDivider(node)) {
return node;
}
node = node.nextElementSibling;
}
return null;
}
function findHeaderBetween(startDivider, endDivider) {
let node = startDivider.nextElementSibling;
let firstParagraph = null;
while (node && node !== endDivider) {
if (isHeader(node)) {
return node;
}
if (!firstParagraph && node.nodeType === 1 && node.tagName === 'P') {
firstParagraph = node;
}
node = node.nextElementSibling;
}
if (!endDivider) {
while (node) {
if (isHeader(node)) {
return node;
}
if (!firstParagraph && node.nodeType === 1 && node.tagName === 'P') {
firstParagraph = node;
}
node = node.nextElementSibling;
}
}
return firstParagraph;
}
function wrapAnswerContent(header, endDivider) {
let node = header.nextSibling;
const wrapper = document.createElement('div');
wrapper.className = 'faq-answer';
let hasContent = false;
while (node && node !== endDivider) {
const next = node.nextSibling;
wrapper.appendChild(node);
hasContent = true;
node = next;
}
if (!hasContent) {
return null;
}
if (endDivider && endDivider.parentNode) {
header.parentNode.insertBefore(wrapper, endDivider);
} else {
header.parentNode.appendChild(wrapper);
}
return wrapper;
}
function prepareToggle(header, answer, openByDefault = false) {
header.classList.add('faq-question');
header.dataset.faqBound = 'true';
if (!header.hasAttribute('tabindex')) {
header.setAttribute('tabindex', '0');
}
header.setAttribute('role', 'button');
if (!answer.id) {
answerIdCounter += 1;
answer.id = `faq-answer-${answerIdCounter}`;
}
header.setAttribute('aria-controls', answer.id);
if (answerResizeObserver) {
answerResizeObserver.observe(answer);
}
if (openByDefault) {
header.classList.add('is-open');
header.classList.remove('is-closed');
answer.classList.add('is-open');
answer.classList.remove('is-closed');
header.setAttribute('aria-expanded', 'true');
answer.setAttribute('aria-hidden', 'false');
openAnswers.add(answer);
requestFrame(() => adjustHeight(answer));
} else {
header.classList.add('is-closed');
header.classList.remove('is-open');
answer.classList.add('is-closed');
answer.classList.remove('is-open');
header.setAttribute('aria-expanded', 'false');
answer.setAttribute('aria-hidden', 'true');
}
const toggle = () => toggleAnswer(header, answer);
header.addEventListener('click', toggle);
header.addEventListener('keydown', event => {
if (event.key === 'Enter' || event.key === ' ') {
event.preventDefault();
toggle();
}
});
}
function toggleAnswer(header, answer) {
const willOpen = !header.classList.contains('is-open');
if (willOpen && !CONFIG.allowMultipleOpen) {
openAnswers.forEach(openAnswer => {
if (openAnswer !== answer) {
const openHeader = document.querySelector(`[aria-controls="${openAnswer.id}"]`);
if (openHeader) {
openHeader.classList.remove('is-open');
openHeader.classList.add('is-closed');
openHeader.setAttribute('aria-expanded', 'false');
}
openAnswer.classList.remove('is-open');
openAnswer.classList.add('is-closed');
openAnswer.setAttribute('aria-hidden', 'true');
openAnswer.style.maxHeight = '0px';
openAnswers.delete(openAnswer);
}
});
}
header.classList.toggle('is-open', willOpen);
header.classList.toggle('is-closed', !willOpen);
answer.classList.toggle('is-open', willOpen);
answer.classList.toggle('is-closed', !willOpen);
header.setAttribute('aria-expanded', String(willOpen));
answer.setAttribute('aria-hidden', String(!willOpen));
if (willOpen) {
openAnswers.add(answer);
adjustHeight(answer);
scheduleOpenAnswerSync();
} else {
openAnswers.delete(answer);
answer.style.maxHeight = '0px';
}
}
function adjustHeight(answer) {
answer.style.maxHeight = `${answer.scrollHeight}px`;
}
function isHeader(node) {
return node && node.nodeType === 1 && HEADER_TAGS.has(node.tagName);
}
function isDivider(node) {
return (
node &&
node.nodeType === 1 &&
node.tagName === 'HR' &&
node.classList.contains('divider-component')
);
}
})();
/**
* Columns Plugin
* Combines Grid Cluster and Cards functionality.
*
* - Grid Cluster: Wraps consecutive `.grid-*` containers into a responsive grid.
* - Cards: Applies styling (padding, border radius, background) to card items.
*/
(function() {
'use strict';
const DEFAULTS = {
gridClasses: ['grid-2', 'grid-3', 'grid-4', 'grid-5', 'grid-6'],
cardSelector: '.cards',
defaultCardBg: 'var(--mini-card-bg-default)',
widthClasses: {
'w-20': '20%',
'w-25': '25%',
'w-30': '33%',
'w-40': '40%',
'w-50': '50%',
'w-60': '60%',
'w-70': '67%',
'w-75': '75%',
'w-80': '80%'
}
};
const externalOptions = (typeof window !== 'undefined' &&
window.CarrdPluginOptions &&
window.CarrdPluginOptions.columns) || {};
const CONFIG = { ...DEFAULTS, ...externalOptions };
const GRID_CLASSES = CONFIG.gridClasses;
const WIDTH_CLASS_MAP = CONFIG.widthClasses;
const GRID_SELECTOR = GRID_CLASSES.map(cls => `.${cls}`).join(',');
const WIDTH_CLASSES = Object.keys(WIDTH_CLASS_MAP);
const isGridBlock = element =>
element && GRID_CLASSES.some(cls => element.classList && element.classList.contains(cls));
const getGridSize = element => {
if (!element || !element.classList) return null;
const sizeClass = GRID_CLASSES.find(cls => element.classList.contains(cls));
if (!sizeClass) return null;
const numeric = parseInt(sizeClass.split('-')[1], 10);
return Number.isNaN(numeric) ? null : numeric;
};
const widthValueForElement = element => {
if (!element || !element.classList) return null;
const widthClass = WIDTH_CLASSES.find(cls => element.classList.contains(cls));
return widthClass ? WIDTH_CLASS_MAP[widthClass] : null;
};
function wrapCluster(cluster, gridSize) {
if (!cluster.length || !cluster[0].parentNode) return;
const container = document.createElement('div');
const classList = ['custom-grid-container'];
if (gridSize && gridSize >= 2) {
classList.push(`grid-${gridSize}`);
}
if (cluster.some(el => el.classList.contains('grid-sm-2'))) {
classList.push('grid-sm-2');
}
container.className = classList.join(' ');
cluster[0].parentNode.insertBefore(container, cluster[0]);
cluster.forEach(node => container.appendChild(node));
applyDesktopWidths(container, cluster, gridSize);
}
function applyDesktopWidths(container, cluster, gridSize) {
if (!gridSize || gridSize < 2 || cluster.length < gridSize) return;
const initialRow = cluster.slice(0, gridSize);
const columnWidths = initialRow.map(widthValueForElement);
if (!columnWidths.some(Boolean)) return;
const templateParts = columnWidths.map(value => value || 'minmax(0, 1fr)');
container.classList.add('custom-grid-container--desktop-widths');
container.style.setProperty('--custom-desktop-template', templateParts.join(' '));
}
function constrainImageFrames() {
document.querySelectorAll('.custom-grid-container .image-component > .frame').forEach(frame => {
const computedWidth = window.getComputedStyle(frame).width;
const widthInRem = parseFloat(computedWidth) / parseFloat(getComputedStyle(document.documentElement).fontSize);
if (widthInRem > 20) {
frame.classList.add('constrain-width');
}
});
}
function initGridCluster() {
const collected = new Set();
const gridBlocks = document.querySelectorAll(GRID_SELECTOR);
gridBlocks.forEach(block => {
if (collected.has(block)) return;
if (block.dataset.gridInitialized === 'true') return;
const cluster = [block];
const baseSize = getGridSize(block);
let sibling = block.nextElementSibling;
while (isGridBlock(sibling)) {
const siblingSize = getGridSize(sibling);
if (baseSize !== null && siblingSize !== baseSize) {
break;
}
cluster.push(sibling);
collected.add(sibling);
sibling = sibling.nextElementSibling;
}
collected.add(block);
cluster.forEach(node => node.dataset.gridInitialized = 'true');
wrapCluster(cluster, baseSize);
});
constrainImageFrames();
}
const parsePadding = (val) => {
if (!val) return null;
return val.split(' ').map(v => !isNaN(v) ? v + 'rem' : v).join(' ');
};
const initCards = () => {
const cardContainers = document.querySelectorAll(CONFIG.cardSelector);
cardContainers.forEach(container => {
if (container.dataset.cardsInitialized === 'true') return;
container.dataset.cardsInitialized = 'true';
const style = window.getComputedStyle(container);
const backgroundColor = style.backgroundColor;
const borderRadius = style.borderRadius;
const borderTopWidth = style.borderTopWidth;
const borderTopStyle = style.borderTopStyle;
const borderTopColor = style.borderTopColor;
const boxShadow = style.boxShadow;
const backgroundImage = style.backgroundImage;
const backgroundPosition = style.backgroundPosition;
const backgroundRepeat = style.backgroundRepeat;
const backgroundSize = style.backgroundSize;
const dataPadding = parsePadding(container.dataset.padding);
const dataPaddingMobile = parsePadding(container.dataset.paddingMobile);
const dataColor = container.dataset.color;
container.style.setProperty('border', 'none', 'important');
container.style.setProperty('box-shadow', 'none', 'important');
if (!dataColor) {
container.style.setProperty('background-color', 'transparent', 'important');
container.style.setProperty('background', 'none', 'important');
}
const inner = container.querySelector('.inner');
if (!inner) return;
const columns = Array.from(inner.children);
columns.forEach((column, index) => {
if (column.querySelector('.card-item')) return;
const cardItem = document.createElement('div');
cardItem.classList.add('card-item');
const specificColor = container.getAttribute(`data-color-${index + 1}`);
const specificBorderColor = container.getAttribute(`data-border-color-${index + 1}`);
if (specificColor) {
cardItem.style.backgroundColor = specificColor;
} else if (dataColor) {
cardItem.style.backgroundColor = dataColor;
} else if (backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent') {
cardItem.style.backgroundColor = backgroundColor;
} else {
cardItem.style.backgroundColor = CONFIG.defaultCardBg;
}
if (borderRadius && borderRadius !== '0px') {
cardItem.style.setProperty('--mini-card-border-radius', borderRadius);
}
if (borderTopWidth && borderTopWidth !== '0px' && borderTopStyle !== 'none') {
cardItem.style.borderWidth = borderTopWidth;
cardItem.style.borderStyle = borderTopStyle;
cardItem.style.borderColor = specificBorderColor || borderTopColor;
}
if (boxShadow && boxShadow !== 'none') {
cardItem.style.boxShadow = boxShadow;
}
if (!dataColor && !specificColor && backgroundImage && backgroundImage !== 'none') {
cardItem.style.backgroundImage = backgroundImage;
cardItem.style.backgroundPosition = backgroundPosition;
cardItem.style.backgroundRepeat = backgroundRepeat;
cardItem.style.backgroundSize = backgroundSize;
}
if (dataPadding) {
cardItem.style.setProperty('--mini-card-padding', dataPadding);
}
if (dataPaddingMobile) {
cardItem.style.setProperty('--mini-card-padding-mobile', dataPaddingMobile);
}
while (column.firstChild) {
cardItem.appendChild(column.firstChild);
}
column.appendChild(cardItem);
});
});
};
function init() {
initGridCluster();
initCards();
}
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}
})();
(function () {
"use strict";
const DEFAULTS = {
animationDuration: 750,      // Duration for is-playing class (ms)
observerTimeout: 5000,       // Auto-disconnect observers after this time (ms)
scrollPulseInterval: 60,     // Interval between scroll/resize pulses (ms)
scrollPulseCount: 10,        // Number of interval pulses
rafPulseCount: 4             // Number of requestAnimationFrame pulses
};
const externalOptions = (typeof window !== 'undefined' &&
window.CarrdPluginOptions &&
window.CarrdPluginOptions.noLoadwaiting) || {};
const CONFIG = {};
for (const key in DEFAULTS) {
CONFIG[key] = externalOptions.hasOwnProperty(key) ? externalOptions[key] : DEFAULTS[key];
}
let initialized = false;
let cachedBody = null;
function getBody() {
if (cachedBody && cachedBody.isConnected) return cachedBody;
cachedBody = document.body;
return cachedBody;
}
function markReadyNow() {
const body = getBody();
if (!body) return;
body.classList.remove("is-loading", "with-loader");
if (!body.classList.contains("is-ready")) {
body.classList.add("is-ready");
body.classList.add("is-playing");
setTimeout(function () {
body.classList.remove("is-playing");
}, CONFIG.animationDuration);
}
}
function hideLoaderIfPresent() {
const loader = document.getElementById("loader");
if (!loader) return false;
loader.style.cssText = "display:none !important; visibility:hidden !important; opacity:0 !important; pointer-events:none !important;";
return true;
}
function kickScrollHandlers() {
let pulses = 0;
const timer = setInterval(function () {
if (++pulses >= CONFIG.scrollPulseCount) {
clearInterval(timer);
return;
}
dispatchLayoutEvents();
}, CONFIG.scrollPulseInterval);
let rafPulses = 0;
(function rafTick() {
dispatchLayoutEvents();
if (++rafPulses < CONFIG.rafPulseCount) requestAnimationFrame(rafTick);
})();
}
function dispatchLayoutEvents() {
try {
window.dispatchEvent(new Event("resize"));
window.dispatchEvent(new Event("scroll"));
} catch (e) {
/* ignore */
}
}
function setupObservers() {
const body = getBody();
if (!body) return;
const classObserver = new MutationObserver(function () {
if (body.classList.contains("with-loader")) {
body.classList.remove("with-loader");
}
});
const childObserver = new MutationObserver(function () {
if (hideLoaderIfPresent()) {
childObserver.disconnect();
}
});
classObserver.observe(body, {
attributes: true,
attributeFilter: ["class"],
});
childObserver.observe(body, { childList: true });
setTimeout(function () {
classObserver.disconnect();
childObserver.disconnect();
}, CONFIG.observerTimeout);
}
function init() {
if (initialized) return;
initialized = true;
try {
markReadyNow();
hideLoaderIfPresent();
setupObservers();
kickScrollHandlers();
} catch (e) {
console.warn("early-animate-override failed:", e);
}
}
if (document.readyState === "loading") {
document.addEventListener("DOMContentLoaded", init, { once: true });
} else {
init();
}
})();
/**
* Carrd Shopping Cart Plugin - JS Logic
*
* INSTRUCTIONS:
* 1. JS: Copy this code (keeping the <script> tags) into a "Settings > Head" or "Embed" element.
* 2. CSS: Copy the code from 'carrd-cart.css' into a separate "Embed" element (Type: Code, Style: Hidden Head).
* 3. USAGE: Link a button to "On Click" -> CartPlugin.add('Item', 99)
*/
(function() {
'use strict';
const DEFAULTS = {
currency: '$',
currencyPosition: 'before', // 'before' ($10) or 'after' (10$)
position: 'top-right', // 'bottom-right', 'top-right', 'bottom-left', 'bottom-center'
storageKey: 'carrd_cart_v1',
orderInputSelector: '[name="order-details"], #order-details', // Default field
orderInputClass: '.cart-output', // Alternative class for flexibility
texts: {
title: 'Shopping Cart',
empty: 'Your cart is empty.',
checkout: 'Checkout',
total: 'Total',
remove: 'Remove',
required: 'Required',
addedToCart: 'Added "${name}" to cart',
errorName: 'Invalid product name',
errorPrice: 'Invalid price for ${name}',
errorForm: 'Error: Could not find the order form. Please contact support.',
consoleErrorForm: 'Carrd Cart: Could not find "Order Details" field. Please ensure a Textarea with name="order-details" or ID="order-details" exists.'
}
};
/**
* Deep merge utility for nested configuration objects
* @param {Object} target - Base/default object
* @param {Object} source - Override object
* @returns {Object} - Merged object
*/
function deepMerge(target, source) {
if (!source || typeof source !== 'object') return target;
const result = { ...target };
for (const key in source) {
if (Object.prototype.hasOwnProperty.call(source, key)) {
if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
result[key] = deepMerge(target[key] || {}, source[key]);
} else {
result[key] = source[key];
}
}
}
return result;
}
const externalOptions = (typeof window !== 'undefined' &&
window.CarrdPluginOptions &&
window.CarrdPluginOptions.shoppingCart) || {};
const CONFIG = deepMerge(DEFAULTS, externalOptions);
/**
* Escapes HTML special characters to prevent XSS attacks
* @param {string} str - Input string
* @returns {string} - Escaped string safe for HTML insertion
*/
function escapeHtml(str) {
if (typeof str !== 'string') return '';
const div = document.createElement('div');
div.textContent = str;
return div.innerHTML;
}
/**
* Escapes a string for use in JavaScript string literals (onclick handlers)
* @param {string} str - Input string
* @returns {string} - Escaped string safe for JS string context
*/
function escapeJsString(str) {
if (typeof str !== 'string') return '';
return str
.replace(/\\/g, '\\\\')
.replace(/'/g, "\\'")
.replace(/"/g, '\\"')
.replace(/</g, '\\x3c')
.replace(/>/g, '\\x3e');
}
/**
* Validates a cart item from localStorage
* @param {Object} item - Cart item to validate
* @returns {boolean} - True if valid
*/
function validateCartItem(item) {
if (!item || typeof item !== 'object') return false;
if (typeof item.name !== 'string' || item.name.length === 0 || item.name.length > 200) return false;
if (typeof item.price !== 'number' || isNaN(item.price) || item.price < 0) return false;
if (typeof item.qty !== 'number' || !Number.isInteger(item.qty) || item.qty < 1) return false;
return true;
}
let state = {
cart: [],
isOpen: false
};
try {
const stored = localStorage.getItem(CONFIG.storageKey);
if (stored) {
const parsed = JSON.parse(stored);
if (Array.isArray(parsed)) {
state.cart = parsed.filter(validateCartItem);
}
}
} catch (e) {
console.warn('LocalStorage not available or corrupted');
state.cart = [];
}
const saveState = () => {
try {
localStorage.setItem(CONFIG.storageKey, JSON.stringify(state.cart));
} catch (e) {}
updateUI();
};
const CartAPI = {
/**
* Add an item to the cart
* @param {string} name - Product name
* @param {number|string} price - Product price
*/
add: function(name, price) {
if (typeof name !== 'string' || name.trim().length === 0) {
console.error(CONFIG.texts.errorName);
return;
}
name = name.trim();
if (name.length > 200) {
console.error('Product name too long (max 200 chars)');
return;
}
price = parseFloat(price);
if (isNaN(price) || price < 0) {
console.error(CONFIG.texts.errorPrice.replace('${name}', name));
return;
}
const existing = state.cart.find(item => item.name === name);
if (existing) {
existing.qty++;
} else {
state.cart.push({ name, price, qty: 1 });
}
saveState();
showToast(CONFIG.texts.addedToCart.replace('${name}', name));
if (state.cart.length === 1 && state.cart[0].qty === 1) {
this.open();
}
},
remove: function(name) {
state.cart = state.cart.filter(item => item.name !== name);
saveState();
},
updateQty: function(name, delta) {
const item = state.cart.find(i => i.name === name);
if (!item) return;
item.qty += delta;
if (item.qty <= 0) {
this.remove(name);
} else {
saveState();
}
},
clear: function() {
state.cart = [];
saveState();
},
getCart: function() {
return [...state.cart];
},
getTotal: function() {
return state.cart.reduce((sum, item) => sum + (item.price * item.qty), 0);
},
open: function() {
state.isOpen = true;
updateUI();
},
close: function() {
state.isOpen = false;
updateUI();
},
checkout: function() {
if (state.cart.length === 0) return;
const total = this.getTotal();
const summary = [
'--- ORDER DETAILS ---',
...state.cart.map(item => `${item.qty} x ${item.name}: ${formatPrice(item.price * item.qty)}`),
'---------------------',
`TOTAL: ${formatPrice(total)}`
].join('\n');
const orderField =
document.querySelector(CONFIG.orderInputSelector) ||
document.querySelector(CONFIG.orderInputClass) ||
document.querySelector('[name="order-details"]') ||
document.querySelector('#order-details');
if (!orderField) {
console.error(CONFIG.texts.consoleErrorForm);
alert(CONFIG.texts.errorForm);
return;
}
orderField.value = summary;
this.close();
window.location.href = '#shopping-cart';
},
/**
* Configure plugin options at runtime
* @param {Object} options - Configuration options to merge
*/
configure: function(options) {
if (!options || typeof options !== 'object') return;
const merged = deepMerge(CONFIG, options);
Object.assign(CONFIG, merged);
updateUI(); // Re-render with new settings
},
/**
* Get current configuration
* @returns {Object} - Current configuration object (copy)
*/
getConfig: function() {
return JSON.parse(JSON.stringify(CONFIG));
}
};
window.CartPlugin = CartAPI;
window.CarrdCart = CartAPI; // Alias for backward compatibility
const ICONS = {
cart: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>`,
close: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`,
trash: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
plus: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`,
minus: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>`
};
function formatPrice(amount) {
const fixed = amount.toFixed(2);
return CONFIG.currencyPosition === 'before'
? `${CONFIG.currency}${fixed}`
: `${fixed}${CONFIG.currency}`;
}
function renderCartItems() {
if (state.cart.length === 0) {
return `<div style="text-align: center; padding: 40px 0; opacity: 0.6;">${escapeHtml(CONFIG.texts.empty)}</div>`;
}
return state.cart.map(item => {
const safeName = escapeHtml(item.name);
const safeNameJs = escapeJsString(item.name);
return `
<div class="crt-item">
<div class="crt-item-info">
<span class="crt-item-name">${safeName}</span>
<span class="crt-item-price">${formatPrice(item.price)}</span>
</div>
<div class="crt-controls">
<button class="crt-btn-qty" data-action="update-qty" data-name="${safeName}" data-qty="-1" aria-label="Decrease quantity for ${safeName}">${ICONS.minus}</button>
<span>${item.qty}</span>
<button class="crt-btn-qty" data-action="update-qty" data-name="${safeName}" data-qty="1" aria-label="Increase quantity for ${safeName}">${ICONS.plus}</button>
<button class="crt-btn-qty crt-btn-remove" style="margin-left:5px" data-action="remove" data-name="${safeName}" aria-label="Remove ${safeName} from cart">${ICONS.trash}</button>
</div>
</div>
`;
}).join('');
}
function updateUI() {
const container = document.getElementById('crt-container');
if (!container) return;
const widget = container.querySelector('.crt-widget');
const badge = container.querySelector('.crt-badge');
const totalQty = state.cart.reduce((s, i) => s + i.qty, 0);
if (state.cart.length > 0) {
widget.classList.add('visible');
} else {
widget.classList.remove('visible');
}
if (badge) {
badge.textContent = totalQty;
badge.style.display = totalQty > 0 ? 'block' : 'none';
}
const overlay = container.querySelector('.crt-overlay');
const panel = container.querySelector('.crt-panel');
if (state.isOpen) {
overlay.classList.add('open');
panel.classList.add('open');
} else {
overlay.classList.remove('open');
panel.classList.remove('open');
}
const bodyContent = container.querySelector('.crt-body');
const footerContent = container.querySelector('.crt-footer');
const titleContent = container.querySelector('.crt-title');
titleContent.textContent = CONFIG.texts.title;
bodyContent.innerHTML = renderCartItems();
footerContent.style.display = 'block';
container.querySelector('.crt-total-amount').textContent = formatPrice(CartPlugin.getTotal());
const checkoutBtn = container.querySelector('.crt-btn-checkout');
if (checkoutBtn) {
checkoutBtn.disabled = state.cart.length === 0;
}
}
function createWidget() {
const div = document.createElement('div');
div.id = 'crt-container';
const posMap = {
'bottom-right': 'crt-pos-br',
'top-right': 'crt-pos-tr',
'bottom-left': 'crt-pos-bl',
'bottom-center': 'crt-pos-bc'
};
const posClass = posMap[CONFIG.position] || 'crt-pos-br';
div.innerHTML = `
<div class="crt-widget ${posClass}" data-action="open" role="button" aria-label="Open Shopping Cart" tabindex="0">
${ICONS.cart}
<div class="crt-badge" style="display:none">0</div>
</div>
<div class="crt-overlay" data-action="close"></div>
<div class="crt-panel">
<div class="crt-header">
<h2 class="crt-title">${CONFIG.texts.title}</h2>
<button class="crt-close" data-action="close" aria-label="Close Cart">${ICONS.close}</button>
</div>
<div class="crt-body"></div>
<div class="crt-footer">
<div class="crt-total-row">
<span>${CONFIG.texts.total}</span>
<span class="crt-total-amount">$0.00</span>
</div>
<button class="crt-btn-main crt-btn-checkout" data-action="checkout">${CONFIG.texts.checkout}</button>
</div>
</div>
<div class="crt-toast"></div>
`;
document.body.appendChild(div);
div.addEventListener('click', (e) => {
const trigger = e.target.closest('[data-action]');
if (!trigger) return;
const action = trigger.dataset.action;
const name = trigger.dataset.name;
if (trigger.tagName === 'BUTTON') e.preventDefault();
switch (action) {
case 'open':
CartPlugin.open();
break;
case 'close':
CartPlugin.close();
break;
case 'checkout':
CartPlugin.checkout();
break;
case 'update-qty':
const delta = parseInt(trigger.dataset.qty);
if (name && !isNaN(delta)) CartPlugin.updateQty(name, delta);
break;
case 'remove':
if (name) CartPlugin.remove(name);
break;
}
});
div.addEventListener('keydown', (e) => {
if (e.key === 'Enter' || e.key === ' ') {
const trigger = e.target.closest('[data-action="open"]');
if (trigger) {
e.preventDefault();
CartPlugin.open();
}
}
});
}
function showToast(msg) {
const toast = document.querySelector('.crt-toast');
if (!toast) return;
toast.textContent = msg;
toast.classList.add('visible');
setTimeout(() => toast.classList.remove('visible'), 3000);
}
function init() {
if (document.getElementById('crt-container')) return; // Prevent double init
createWidget();
updateUI();
}
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}
})();