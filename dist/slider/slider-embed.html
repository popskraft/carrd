<style>
.slider-wrapper{position:relative;overflow:hidden;width:100%;cursor:grab;touch-action:pan-y;-webkit-user-select:none;user-select:none}.slider-wrapper.is-dragging{cursor:grabbing}.slider-track{display:flex;transition:transform 0.3s ease-out;will-change:transform;touch-action:pan-y}.slider-wrapper.is-dragging .slider-track{transition:none}.slider-track>.slider-slide{flex:0 0 auto;box-sizing:border-box;touch-action:pan-y;position:relative}.slider-wrapper.is-equal-height .slider-slide{display:flex;flex-direction:column;height:auto}.slider-wrapper.is-equal-height .slider-slide>.container-component{flex-grow:1;display:flex;flex-direction:column}.slider-wrapper.is-equal-height .slider-slide>.container-component>.wrapper{flex-grow:1}.slider-dots{display:flex;justify-content:center;gap:0.5rem;margin-top:var(--mini-slider-dots-margin, 1rem);padding:0.5rem 0}.slider-dot{width:var(--mini-slider-dot-size, 10px);height:var(--mini-slider-dot-size, 10px);border-radius:50%;background:var(--mini-slider-dot-bg, rgba(0, 0, 0, 0.2));border:none;padding:0;cursor:pointer;transition:background 0.2s ease, transform 0.2s ease}.slider-dot:hover{background:var(--mini-slider-dot-hover-bg, rgba(0, 0, 0, 0.4))}.slider-dot.is-active{background:var(--mini-slider-dot-active-bg, var(--mini-color-primary, #5c9dff));transform:scale(1.2)}.slider-nav{position:absolute;top:50%;transform:translateY(-50%);width:var(--mini-slider-arrow-size, 40px);height:var(--mini-slider-arrow-size, 40px);background:var(--mini-slider-arrow-bg, rgba(255, 255, 255, 0.9));border:none;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0, 0, 0, 0.15);transition:opacity 0.2s ease, transform 0.2s ease;z-index:10;opacity:0;pointer-events:none}.slider-wrapper:hover .slider-nav{opacity:1;pointer-events:auto}.slider-nav:hover{transform:translateY(-50%) scale(1.1)}.slider-nav:disabled{opacity:0 !important;visibility:hidden;pointer-events:none}.slider-nav--prev{left:var(--mini-slider-arrow-offset, 0.5rem)}.slider-nav--next{right:var(--mini-slider-arrow-offset, 0.5rem)}.slider-nav svg{width:20px;height:20px;stroke:var(--mini-slider-arrow-color, #333);stroke-width:2;fill:none}.slider-slide>.container-component{margin:0 !important}.slider-slide>.container-component>.wrapper{width:100% !important}@media screen and (max-width:736px){.slider-nav{display:none}.slider-dots{margin-top:var(--mini-slider-dots-margin-mobile, 0.75rem)}}@media (prefers-reduced-motion:reduce){.slider-track{transition:none}.slider-dot, .slider-nav{transition:none}}
</style>
<script>
/**
* Slider Plugin
* Creates horizontal sliders from consecutive containers with class "slider".
*
* Features:
* - Touch swipe support
* - Mouse drag support
* - Navigation dots
* - Optional arrow navigation
* - Responsive slidesPerView with breakpoints
*/
(function() {
'use strict';
const DEFAULTS = {
slideSelector: '.slider',
wrapperClass: 'slider-wrapper',
trackClass: 'slider-track',
slideClass: 'slider-slide',
showDots: true,
showArrows: true,
loop: false,
autoplay: false,
autoplayInterval: 5000,
dragThreshold: 50,
snapThreshold: 0.3,
gap: 16, // Gap between slides in pixels
slidesPerView: 1,
peek: 0, // Fraction of next slide to show (e.g. 0.1 for 10%)
equalHeight: false, // Stretch slides to same height
breakpoints: {
737: { slidesPerView: 3 },
1280: { slidesPerView: 4 }
}
};
const externalOptions = (typeof window !== 'undefined' &&
window.CarrdPluginOptions &&
window.CarrdPluginOptions.slider) || {};
const CONFIG = {
...DEFAULTS,
...externalOptions,
breakpoints: { ...DEFAULTS.breakpoints, ...(externalOptions.breakpoints || {}) }
};
const ICONS = {
prev: `<svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg>`,
next: `<svg viewBox="0 0 24 24"><polyline points="9 6 15 12 9 18"></polyline></svg>`
};
class Slider {
constructor(slides) {
this.slides = slides;
this.currentIndex = 0;
this.isDragging = false;
this.startX = 0;
this.currentX = 0;
this.translateX = 0;
this.autoplayTimer = null;
this.slidesPerView = CONFIG.slidesPerView;
this.init();
}
init() {
this.createWrapper();
this.createTrack();
this.wrapSlides();
if (CONFIG.showDots && this.slides.length > 1) {
this.createDots();
}
if (CONFIG.showArrows && this.slides.length > 1) {
this.createArrows();
}
this.bindEvents();
this.updateSlidesPerView();
this.updateSlider();
if (CONFIG.autoplay && this.slides.length > 1) {
this.startAutoplay();
}
}
createWrapper() {
this.wrapper = document.createElement('div');
this.wrapper.className = CONFIG.wrapperClass;
if (CONFIG.equalHeight) {
this.wrapper.classList.add('is-equal-height');
}
this.slides[0].parentNode.insertBefore(this.wrapper, this.slides[0]);
}
createTrack() {
this.track = document.createElement('div');
this.track.className = CONFIG.trackClass;
this.wrapper.appendChild(this.track);
}
wrapSlides() {
this.slides.forEach((slide, index) => {
const slideWrapper = document.createElement('div');
slideWrapper.className = CONFIG.slideClass;
slideWrapper.dataset.slideIndex = index;
slideWrapper.appendChild(slide);
this.track.appendChild(slideWrapper);
});
this.slideElements = Array.from(this.track.querySelectorAll(`.${CONFIG.slideClass}`));
}
createDots() {
this.dotsContainer = document.createElement('div');
this.dotsContainer.className = 'slider-dots';
this.wrapper.appendChild(this.dotsContainer);
}
updateDots() {
if (!this.dotsContainer) return;
this.dotsContainer.innerHTML = '';
const totalPages = this.getTotalPages();
if (totalPages <= 1) {
this.dotsContainer.style.display = 'none';
return;
}
this.dotsContainer.style.display = 'flex';
for (let i = 0; i < totalPages; i++) {
const dot = document.createElement('button');
dot.className = 'slider-dot';
if (i === this.currentIndex) {
dot.classList.add('is-active');
}
dot.setAttribute('aria-label', `Go to slide ${i + 1}`);
dot.dataset.index = i;
dot.addEventListener('click', () => this.goToSlide(i));
this.dotsContainer.appendChild(dot);
}
this.dots = this.dotsContainer.querySelectorAll('.slider-dot');
}
createArrows() {
this.prevBtn = document.createElement('button');
this.prevBtn.className = 'slider-nav slider-nav--prev';
this.prevBtn.setAttribute('aria-label', 'Previous slide');
this.prevBtn.innerHTML = ICONS.prev;
this.prevBtn.addEventListener('click', () => this.prev());
this.nextBtn = document.createElement('button');
this.nextBtn.className = 'slider-nav slider-nav--next';
this.nextBtn.setAttribute('aria-label', 'Next slide');
this.nextBtn.innerHTML = ICONS.next;
this.nextBtn.addEventListener('click', () => this.next());
this.wrapper.appendChild(this.prevBtn);
this.wrapper.appendChild(this.nextBtn);
}
bindEvents() {
const dragTarget = this.wrapper;
dragTarget.addEventListener('touchstart', this.onDragStart.bind(this), { passive: true, capture: true });
dragTarget.addEventListener('touchmove', this.onDragMove.bind(this), { passive: false, capture: true });
dragTarget.addEventListener('touchend', this.onDragEnd.bind(this), { capture: true });
dragTarget.addEventListener('touchcancel', this.onDragEnd.bind(this), { capture: true });
dragTarget.addEventListener('mousedown', this.onDragStart.bind(this), { capture: true });
dragTarget.addEventListener('mousemove', this.onDragMove.bind(this), { capture: true });
dragTarget.addEventListener('mouseup', this.onDragEnd.bind(this), { capture: true });
dragTarget.addEventListener('mouseleave', this.onDragEnd.bind(this), { capture: true });
dragTarget.addEventListener('dragstart', (e) => e.preventDefault());
this.wrapper.setAttribute('tabindex', '0');
this.wrapper.addEventListener('keydown', (e) => {
if (e.key === 'ArrowLeft') this.prev();
if (e.key === 'ArrowRight') this.next();
});
if (CONFIG.autoplay) {
this.wrapper.addEventListener('mouseenter', () => this.stopAutoplay());
this.wrapper.addEventListener('mouseleave', () => this.startAutoplay());
}
let resizeTimeout;
window.addEventListener('resize', () => {
clearTimeout(resizeTimeout);
resizeTimeout = setTimeout(() => {
this.updateSlidesPerView();
this.updateSlider();
}, 100);
});
}
updateSlidesPerView() {
const windowWidth = window.innerWidth;
let newSlidesPerView = CONFIG.slidesPerView;
const breakpointKeys = Object.keys(CONFIG.breakpoints)
.map(Number)
.sort((a, b) => a - b);
for (const bp of breakpointKeys) {
if (windowWidth >= bp) {
newSlidesPerView = CONFIG.breakpoints[bp].slidesPerView || newSlidesPerView;
}
}
if (CONFIG.peek) {
newSlidesPerView += CONFIG.peek;
}
this.slidesPerView = Math.min(newSlidesPerView, this.slides.length);
this.updateSlideWidths();
this.updateDots();
const maxIndex = this.getTotalPages() - 1;
if (this.currentIndex > maxIndex) {
this.currentIndex = Math.max(0, maxIndex);
}
}
updateSlideWidths() {
const gap = CONFIG.gap;
const totalGaps = Math.ceil(this.slidesPerView) - 1;
const slideWidth = `calc((100% - ${totalGaps * gap}px) / ${this.slidesPerView})`;
this.slideElements.forEach((slide, index) => {
slide.style.flex = `0 0 ${slideWidth}`;
slide.style.width = slideWidth;
slide.style.marginRight = index < this.slides.length - 1 ? `${gap}px` : '0';
});
}
getTotalPages() {
return Math.ceil(Math.max(1, this.slides.length - this.slidesPerView + 1));
}
onDragStart(e) {
if (this.slides.length <= 1) return;
this.isDragging = true;
this.wrapper.classList.add('is-dragging');
this.startX = this.getPositionX(e);
this.currentX = this.startX;
this.stopAutoplay();
}
onDragMove(e) {
if (!this.isDragging) return;
this.currentX = this.getPositionX(e);
const diff = this.currentX - this.startX;
let newTranslate = this.translateX + diff;
const maxTranslate = 0;
const minTranslate = this.getMinTranslate();
if (newTranslate > maxTranslate) {
newTranslate = maxTranslate + (diff * 0.2);
} else if (newTranslate < minTranslate) {
newTranslate = minTranslate + ((newTranslate - minTranslate) * 0.2);
}
this.track.style.transform = `translateX(${newTranslate}px)`;
if (e.cancelable && Math.abs(diff) > 10) {
e.preventDefault();
}
}
onDragEnd() {
if (!this.isDragging) return;
this.isDragging = false;
this.wrapper.classList.remove('is-dragging');
const diff = this.currentX - this.startX;
const slideWidth = this.getSlideWidth();
const threshold = slideWidth * CONFIG.snapThreshold;
if (Math.abs(diff) > threshold) {
if (diff > 0) {
this.prev();
} else {
this.next();
}
} else {
this.updateSlider();
}
if (CONFIG.autoplay) {
this.startAutoplay();
}
}
getPositionX(e) {
return e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
}
getSlideWidth() {
if (!this.slideElements || !this.slideElements[0]) return 0;
return this.slideElements[0].offsetWidth + CONFIG.gap;
}
getMinTranslate() {
const slideWidth = this.getSlideWidth();
return -(slideWidth * (this.getTotalPages() - 1));
}
goToSlide(index) {
const maxIndex = this.getTotalPages() - 1;
if (index < 0) {
index = CONFIG.loop ? maxIndex : 0;
} else if (index > maxIndex) {
index = CONFIG.loop ? 0 : maxIndex;
}
this.currentIndex = index;
this.updateSlider();
}
prev() {
this.goToSlide(this.currentIndex - 1);
}
next() {
this.goToSlide(this.currentIndex + 1);
}
updateSlider() {
const slideWidth = this.getSlideWidth();
this.translateX = -slideWidth * this.currentIndex;
this.track.style.transform = `translateX(${this.translateX}px)`;
if (this.dots) {
this.dots.forEach((dot, index) => {
dot.classList.toggle('is-active', index === this.currentIndex);
});
}
if (this.prevBtn && this.nextBtn && !CONFIG.loop) {
this.prevBtn.disabled = this.currentIndex === 0;
this.nextBtn.disabled = this.currentIndex >= this.getTotalPages() - 1;
}
}
startAutoplay() {
this.stopAutoplay();
this.autoplayTimer = setInterval(() => {
this.next();
}, CONFIG.autoplayInterval);
}
stopAutoplay() {
if (this.autoplayTimer) {
clearInterval(this.autoplayTimer);
this.autoplayTimer = null;
}
}
}
function findSliderClusters() {
const allSliders = document.querySelectorAll(CONFIG.slideSelector);
if (!allSliders.length) return [];
const clusters = [];
const processed = new Set();
allSliders.forEach(slide => {
if (processed.has(slide)) return;
if (slide.dataset.sliderInitialized === 'true') return;
const cluster = [slide];
processed.add(slide);
let sibling = slide.nextElementSibling;
while (sibling && sibling.classList.contains('slider')) {
if (processed.has(sibling)) break;
cluster.push(sibling);
processed.add(sibling);
sibling = sibling.nextElementSibling;
}
cluster.forEach(el => el.dataset.sliderInitialized = 'true');
clusters.push(cluster);
});
return clusters;
}
function init() {
const clusters = findSliderClusters();
clusters.forEach(cluster => {
if (cluster.length >= 1) {
new Slider(cluster);
}
});
}
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}
})();
</script>
