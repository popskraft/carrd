<!-- Groups consecutive grid-3/grid-4 blocks into responsive grid containers -->
<style>
  .custom-grid-container {
    --grid-columns: 1;
    --grid-row-gap: 1rem;
    --grid-column-gap: 1rem;
    display: grid;
    grid-template-columns: repeat(var(--grid-columns), minmax(0, 1fr));
    row-gap: var(--grid-row-gap);
    column-gap: var(--grid-column-gap);
  }

  @media (max-width: 736px) {
    .custom-grid-container.grid-sm-2 {
      --grid-columns: 2;
      --grid-row-gap: 1rem;
      --grid-column-gap: 0.5rem;
    }
  }

  @media (min-width: 737px) {
    .custom-grid-container.grid-2,
    .custom-grid-container.grid-3,
    .custom-grid-container.grid-4 {
      --grid-columns: 2;
    }
  }

  @media (min-width: 1025px) {
    .custom-grid-container {
      --grid-row-gap: 2rem;
      --grid-column-gap: 2rem;
    }

    .custom-grid-container.grid-3,
    .custom-grid-container.grid-4 {
      --grid-columns: 3;
    }
  }

  @media (min-width: 1681px) {
    .custom-grid-container.grid-4 {
      --grid-columns: 4;
    }
  }

  /* Force full-width wrappers inside clustered grids despite fixed admin width */
  .custom-grid-container > .container-component > .wrapper {
    width: 100% !important;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  /* Align vertical rhythm with grid gaps */
  .custom-grid-container > .container-component {
    margin: 0;
  }

  .custom-grid-container + .custom-grid-container {
    margin-top: var(--grid-row-gap);
  }

  /* Applied dynamically via JS when frame width > 20rem */
  .custom-grid-container .image-component > .frame.constrain-width {
    width: auto !important;
    max-width: 100%;
  }
</style>

<script>
  // Groups consecutive grid-2/grid-3/grid-4 blocks into responsive grid containers
  (function() {
    const selectors = ['.grid-2', '.grid-3', '.grid-4'];
    
    selectors.forEach(selector => {
      const items = document.querySelectorAll(selector);
      if (!items.length) return;

      let cluster = [];
      
      items.forEach((item, i) => {
        const nextItem = items[i + 1];
        cluster.push(item);
        
        // Check if next element is adjacent in DOM
        const isNextAdjacent = nextItem && item.nextElementSibling === nextItem;
        
        if (!isNextAdjacent || i === items.length - 1) {
          // End of cluster â€” wrap it
          const container = document.createElement('div');
          const gridClass = selector.slice(1);
          container.className = `custom-grid-container ${gridClass}`;
          cluster[0].parentNode.insertBefore(container, cluster[0]);
          cluster.forEach(el => container.appendChild(el));
          cluster = [];
        }
      });
    });

    // Constrain image frames with width > 20rem inside grid containers
    document.querySelectorAll('.custom-grid-container .image-component > .frame').forEach(frame => {
      const computedWidth = window.getComputedStyle(frame).width;
      const widthInRem = parseFloat(computedWidth) / parseFloat(getComputedStyle(document.documentElement).fontSize);
      
      if (widthInRem > 20) {
        frame.classList.add('constrain-width');
      }
    });
  })();
</script>
